#!/usr/bin/python

import sys
import os
import optparse
import tempfile
import hashlib
import base64
import subprocess
import time

import pyfscache

def error(args):
    sys.stderr.write(args)
    sys.stderr.flush()
    sys.exit(1)

class hash_set:
    def __init__(self):
        self.data = ''

    def do_hash(self, s):
        h = hashlib.md5()
        h.update(s)
        return base64.b64encode(h.digest())

    def hash_key(self, key, value):
        self.data = self.data + self.do_hash(key + '=' + self.do_hash(value))

    def hash_argv(self, argv):
        h = ''.join(map(self.do_hash, argv))
        self.hash_key('argv', h)

    def hash_environment(self, option, opt, value, parser):
        # Separate missing and zero values
        if value in os.environ and os.environ[value]:
            hash_arg = value + '=' + self.do_hash(os.environ[value])
        else:
            hash_arg = value
        self.hash_key('env', hash_arg)

    def hash_file_contents(self, option, opt, value, parser):
        try:
            contents = open(value).read()
        except IOError as e:
            error("open: {}: {}\n".format(value, e.strerror))
        hash_arg = value + '=' + self.do_hash(contents)
        self.hash_key('file', hash_arg)

hs = hash_set()


class MyParser(optparse.OptionParser):
    def format_epilog(self, formatter):
        return self.epilog

epilog = '''
cmdcache executes a program and caches its output.
It is assumed that there are no side effects of the program execution
and the data written to stdout depends strictly on the known data.
This data includes: stdin contents, program name, program arguments,
environment variables (only if -e option is given), files contents
(only if -f option is given).

Examples:

    cmdcache -f file -- egrep REGEXP file
    cmdcache -e PATH -- which id
'''
parser = MyParser(epilog=epilog)
parser.add_option('-e', '--environment', action='callback',
        callback=hs.hash_environment, type='str',
        help='indicate that output depends on the environment variable value (and presence)')
parser.add_option('-f', '--file-contents', action='callback',
        callback=hs.hash_file_contents, type='str',
        help='indicate that output depends on the file contents')
parser.add_option('--cache-dir', dest='cache_dir',
        default=os.path.expanduser('~/.cmdcache/'),
        help='specify cache directory (~/.cmdcache/ by default)')
parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
        help='Be verbose and print debug messages')
(options, cmd_argv) = parser.parse_args()
if len(cmd_argv) == 0:
    parser.print_help()
    sys.exit(1)

hs.hash_argv(cmd_argv)

tmp_input = tempfile.NamedTemporaryFile(delete=True)
inp = subprocess.check_output(['tee', tmp_input.name])
hs.hash_key('stdin', inp)

cache = pyfscache.FSCache(options.cache_dir, days=10)
if options.verbose == True:
    sys.stderr.write('Hash = {}\n'.format(hs.data))
try:
    result = cache[hs.data]
    if options.verbose == True:
        sys.stderr.write('Found in cache\n')
    sys.stdout.write(result)
except KeyError:
    tmp_output = tempfile.NamedTemporaryFile(delete=True)
    try:
        cmd_proc = subprocess.Popen(cmd_argv,
                stdin=tmp_input, stdout=subprocess.PIPE)
        tee_proc = subprocess.Popen(['tee', tmp_output.name],
                stdin=cmd_proc.stdout)
        cmd_proc.stdout.close() # tee_proc must be able to receive SIGPIPE

        del tmp_input
        tee_rc = tee_proc.wait()
        cmd_rc = cmd_proc.wait()

    except OSError as e:
        error("popen: {}: {}\n".format(cmd_argv[0], e.strerror))

    # force reopen to avoid potential caching at open() time
    output_data = open(tmp_output.name).read()
    # FIXME: pyfscache doesn't handle MT races
    cache[hs.data] = output_data
